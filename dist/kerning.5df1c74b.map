{"version":3,"sources":["js/kerning.js"],"names":["$","hasSameOrigin","url","replace","match","protocol","user","hostname","port","offset","string","window","location","undefined","substring","fn","findandfilter","selector","ret","filter","add","find","prevObject","parsecss","callback","parseAttributes","parse","str","each","innerHTML","end","disabled","href","mediumApplies","media","get","pathname","search","HTMLtext","styleAttributes","munge","s","rule","processAtRule","trim","split","i","css","length","restore","extend","parsedeclarations","query","style","appendTo","remove","isValidSelector","styleSheet","test","cssText","sheet","cssRules","parseArguments","mungedArguments","a","push","eval","err","munged","index","parsed","decl","slice","join","REbraces","REfull","REatcomment","REcomment_string","REmunged","uid","full","replacement","RE","exec","type","shift","pop","_show","show","hide","which","plugin","arguments","apply","data","$this","removeData","call","queue","dequeue","args","makeArray","name","effects","splice","RESGMLcomment","REnotATag","REtag","tags","tag","attrs","toLowerCase","id","injector","t","splitter","klass","after","text","inject","item","empty","append","methods","init","words","lines","r","children","replaceWith","lettering","method","error","unstack","fontunstack","elem","stack","analyzeStack","elems","generics","baseline","num_fonts","last_resort","inArray","font","testFont","requested_font","baseline_font","span","prepend","baseline_width","width","requested_width","element","Kerning","self","nav","navigator","platform","browserPrefix","document","documentElement","userAgent","indexOf","opera","reduce","pv","cv","osPrefix","_pairs","elements","pairString","usingPairs","els","pairInfo","pairKeys","pairDown","isTransform","pairs","pairElements","pair","char1","nextWord","char2","RegExp","next","html","parent","_repeats","repeatString","usingRepeats","repeatInfo","repeats","repeatElements","repeat","_conditional","usingConditional","fontInfo","fonts","fontElements","elementSet","el","fontInUse","_applyAttribute","attribute","values","conditional","ve","vals","indexValues","keys","transformGroups","custom","valEl","attr","map","val","value","eq","kern","kerning","size","sizes","weight","weights","color","colors","backgroundcolor","transform","transforms","_parse","ignoreParsed","_parsedCSS","property","specificity","action","not","addClass","live","bind","evt","target","refresh","newElementsOnly","jQuery"],"mappings":"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","file":"kerning.5df1c74b.map","sourceRoot":"..","sourcesContent":["/**\r\n * Created by hlbinamyslenia on 12/6/16.\r\n */\r\n/*global jQuery */\r\n/*!\r\n * Kerning.js\r\n * Version: 0.2.1\r\n * Copyright 2011 Joshua Gross\r\n * MIT license\r\n *\r\n * Usage:\r\n *  Include this file anywhere in your HTML\r\n *    <script src=\"kerning.js\"></script>\r\n *\r\n *  Then, add any of the attributes following to your CSS, under any\r\n *  selectors you want modified:\r\n *    -letter-kern, -letter-size, -letter-weight, -letter-color, -letter-transform\r\n *    -word-kern, -word-size, -word-weight, -word-color, -word-transform\r\n *\r\n *  To use pairings (e.g., modify 'a' if 'ab' is paired):\r\n *    -letter-pairs('xy': [value], …)\r\n *    -word-pairs('cat mouse': [value], …)\r\n *\r\n *  To use multiple transforms, you need to use transform \"groups\":\r\n *    -transform-group([transform] [transform] …)\r\n *\r\n *  Sometimes you need to want to use a different size or weight, depending on what\r\n *  font has loaded:\r\n *    font-size: [default size];\r\n *    font-size: if-font('font name': [size], 'font name': [size], …);\r\n *  (The first line is a fallback should Kerning.js not load. This is recommended.)\r\n *\r\n *  That's it! Attributes will be applied automagically.\r\n *\r\n * Examples:\r\n *  Alter first 3 letters:\r\n *    -letter-size: 100px 20px 30px;\r\n *\r\n *  Modify letter pairs:\r\n *    -letter-kern: -letter-pairs('ab': 1px,\r\n *                                'bc': 300px,\r\n *                                's ': 100px);\r\n *\r\n *  Transform the first two letters:\r\n *    -letter-transform: -transform-group(rotate3d(0,0,1,10deg) translate3d(0,10px,0))\r\n *                       -transform-group(translate3d(0,-10px,0) rotate3d(0,0,1,-10deg));\r\n *\r\n *  Modify word pairs:\r\n *    -word-size: -word-pairs('this is': 10em);\r\n *\r\n *  Modify the first 3 words:\r\n *    -word-size: 10em 0.1em 0.2em;\r\n *\r\n *  Using repeat rules:\r\n *    -letter-color: -letter-repeat(even: #f0f0f0, odd: #cccccc);\r\n *    -letter-color: -letter-repeat(2n+1: #f0f0f0);\r\n *\r\n *  Using conditionals:\r\n *    -letter-kern: if-font('Helvetica Neue': 0 1px 1px, 'Helvetica': 0 -1px 0);\r\n *\r\n *  Using conditionals on existing properties for weight or size:\r\n *    font-size: 9.5em;\r\n *    font-size: if-font('Helvetica Neue': 10em, 'Helvetica': 9em);\r\n */\r\n(function($){\r\n    /*!\r\n     * jQuery based CSS parser\r\n     * documentation: http://youngisrael-stl.org/wordpress/2009/01/16/jquery-css-parser/\r\n     * Version: 1.3\r\n     * Copyright (c) 2011 Daniel Wachsstock\r\n     * MIT license\r\n     */\r\n    (function() {\r\n        // utility function to determine whether or not a URL has the same origin as the current location\r\n        // See http://jsfiddle.net/35Jku/35/\r\n        var hasSameOrigin = function(url) {\r\n            return url === url.replace(/^([^\\/]*)\\/\\/([^@]*@)?([^\\/:]+)(:\\d+)?.*/, function(match, protocol, user, hostname, port, offset, string) {\r\n                    protocol = (protocol === \"\") ? window.location.protocol : protocol;\r\n                    port = (port === undefined) ? \"\" : port.substring(1);\r\n                    if (protocol !== window.location.protocol)\r\n                        return \"\"; // \"protocol mismatch: \" + protocol + \" vs. \" + window.location.protocol\r\n                    if (hostname !== window.location.hostname)\r\n                        return \"\"; // \"hostname mismatch: \" + hostname + \" vs. \" + window.location.hostname\r\n                    if (port !== window.location.port)\r\n                        return \"\"; // \"port mismatch: \" + port + \" vs. \" + window.location.port\r\n                    return url;\r\n                });\r\n        }\r\n        // utility function, since we want to allow $('style') and $(document), so we need to look for elements in the jQuery object ($.fn.filter) and elements that are children of the jQuery object ($.fn.find)\r\n        $.fn.findandfilter = function(selector) {\r\n            var ret = this.filter(selector).add(this.find(selector));\r\n            ret.prevObject = ret.prevObject.prevObject; // maintain the filter/end chain correctly (the filter and the find both push onto the chain).\r\n            return ret;\r\n        };\r\n\r\n        $.fn.parsecss = function(callback, parseAttributes) {\r\n            var parse = function(str) { $.parsecss(str, callback) }; // bind the callback\r\n            this.findandfilter('style')\r\n                .each(function(){\r\n                    parse(this.innerHTML);\r\n                })\r\n                .end()\r\n                .findandfilter('link[type=\"text/css\"],link[rel=\"stylesheet\"]')\r\n                .each(function(){\r\n                    // only get the stylesheet if it's not disabled, it won't trigger cross-site security (doesn't start with anything like http:) and it uses the appropriate media)\r\n                    if(!this.disabled && hasSameOrigin(this.href) && $.parsecss.mediumApplies(this.media))\r\n                        $.get(this.href, parse);\r\n                })\r\n                .end();\r\n\r\n            if(parseAttributes) {\r\n                $.get(location.pathname+location.search, 'text', function(HTMLtext) {\r\n                    styleAttributes(HTMLtext, callback);\r\n                });\r\n            }\r\n\r\n            return this;\r\n        };\r\n\r\n        $.parsecss = function(str, callback) {\r\n            var ret = {};\r\n            str = munge(str).replace(/@(([^;`]|`[^b]|`b[^%])*(`b%)?);?/g, function(s, rule) {\r\n                // @rules end with ; or a block, with the semicolon not being part of the rule but the closing brace (represented by `b%) is\r\n                processAtRule($.trim(rule), callback);\r\n                return '';\r\n            });\r\n\r\n            $.each(str.split('`b%'), function(i, css) { // split on the end of a block\r\n                css = css.split('%b`'); // css[0] is the selector; css[1] is the index in munged for the cssText\r\n                if (css.length < 2) return; // invalid css\r\n                css[0] = restore(css[0]);\r\n                ret[css[0]] = $.extend(ret[css[0]] || {}, parsedeclarations(css[1]));\r\n            });\r\n            callback(ret);\r\n        };\r\n        // explanation of the above: munge(str) strips comments and encodes strings and brace-delimited blocks, so that\r\n        // %b` corresponds to { and `b% corresponds to }\r\n        // munge(str) replaces blocks with %b`1`b% (for example)\r\n        //\r\n        // str.split('`b%') splits the text by '}' (which ends every CSS statement)\r\n        // Each so the each(munge(str... function(i,css)\r\n        // is called with css being empty (the string after the last delimiter), an @rule, or a css statement of the form\r\n        // selector %b`n where n is a number (the block was turned into %b`n`b% by munge). Splitting on %b` gives the selector and the\r\n        // number corresponding to the declaration block. parsedeclarations will do restore('%b`'+n+'`b%') to get it back.\r\n\r\n        // if anyone ever implements http://www.w3.org/TR/cssom-view/#the-media-interface, we're ready\r\n        $.parsecss.mediumApplies = (window.media && window.media.query) || function(str) {\r\n                if(!str) return true; // if no descriptor, everything applies\r\n                if(str in media) return media[str];\r\n                var style = $('<style media=\"'+str+'\">body {position: relative; z-index: 1;}</style>').appendTo('head');\r\n                return media[str] = [$('body').css('z-index')==1, style.remove()][0]; // the [x,y][0] is a silly hack to evaluate two expressions and return the first\r\n            };\r\n\r\n        $.parsecss.isValidSelector = function(str) {\r\n            var s = $('<style>'+str+'{}</style>').appendTo('head')[0];\r\n            // s.styleSheet is IE; it accepts illegal selectors but converts them to UNKNOWN. Standards-based (s.shee.cssRules) just reject the rule\r\n            return [s.styleSheet ? !/UNKNOWN/i.test(s.styleSheet.cssText) : !!s.sheet.cssRules.length, $(s).remove()][0]; // the [x,y][0] is a silly hack to evaluate two expressions and return the first\r\n        };\r\n\r\n        $.parsecss.parseArguments = function(str) {\r\n            if(!str) return [];\r\n            var ret = [], mungedArguments = munge(str, true).split(/\\s+/); // can't use $.map because it flattens arrays !\r\n            for (var i = 0; i < mungedArguments.length; ++i) {\r\n                var a = restore(mungedArguments[i]);\r\n                try {\r\n                    ret.push(eval('('+a+')'));\r\n                } catch(err) {\r\n                    ret.push(a);\r\n                }\r\n            }\r\n            return ret;\r\n        };\r\n\r\n        // expose the styleAttributes function\r\n        $.parsecss.styleAttributes = styleAttributes;\r\n\r\n        // caches\r\n        var media = {}; // media description strings\r\n        var munged = {}; // strings that were removed by the parser so they don't mess up searching for specific characters\r\n\r\n        // private functions\r\n\r\n        function parsedeclarations(index) { // take a string from the munged array and parse it into an object of property: value pairs\r\n            var str = munged[index].replace(/^{|}$/g, ''); // find the string and remove the surrounding braces\r\n            str = munge(str); // make sure any internal braces or strings are escaped\r\n            var parsed = {};\r\n            $.each(str.split(';'), function (i, decl) {\r\n                decl = decl.split(':');\r\n                if(decl.length < 2) return;\r\n                parsed[restore(decl[0])] = restore(decl.slice(1).join(':'));\r\n            });\r\n            return parsed;\r\n        }\r\n\r\n        // replace strings and brace-surrounded blocks with %s`number`s% and %b`number`b%. By successively taking out the innermost\r\n        // blocks, we ensure that we're matching braces. No way to do this with just regular expressions. Obviously, this assumes no one\r\n        // would use %s` in the real world.\r\n        // Turns out this is similar to the method that Dean Edwards used for his CSS parser in IE7.js (http://code.google.com/p/ie7-js/)\r\n        var REbraces = /{[^{}]*}/;\r\n        var REfull = /\\[[^\\[\\]]*\\]|{[^{}]*}|\\([^()]*\\)|function(\\s+\\w+)?(\\s*%b`\\d+`b%){2}/; // match pairs of parentheses, brackets, and braces and function definitions.\r\n        var REatcomment = /\\/\\*@((?:[^\\*]|\\*[^\\/])*)\\*\\//g; // comments of the form /*@ text */ have text parsed\r\n        // we have to combine the comments and the strings because comments can contain string delimiters and strings can contain comment delimiters\r\n        // var REcomment = /\\/\\*(?:[^\\*]|\\*[^\\/])*\\*\\/|<!--|-->/g; // other comments are stripped. (this is a simplification of real SGML comments (see http://htmlhelp.com/reference/wilbur/misc/comment.html) , but it's what real browsers use)\r\n        // var REstring = /\\\\.|\"(?:[^\\\\\\\"]|\\\\.|\\\\\\n)*\"|'(?:[^\\\\\\']|\\\\.|\\\\\\n)*'/g; //  match escaped characters and strings\r\n        var REcomment_string = /(?:\\/\\*(?:[^\\*]|\\*[^\\/])*\\*\\/)|(\\\\.|\"(?:[^\\\\\\\"]|\\\\.|\\\\\\n)*\"|'(?:[^\\\\\\']|\\\\.|\\\\\\n)*')/g;\r\n        var REmunged = /%\\w`(\\d+)`\\w%/;\r\n        var uid = 0; // unique id number\r\n        function munge(str, full) {\r\n            str = str\r\n                .replace(REatcomment,'$1') // strip /*@ comments but leave the text (to let invalid CSS through)\r\n                .replace(REcomment_string, function (s, string) { // strip strings and escaped characters, leaving munged markers, and strip comments\r\n                    if (!string) return '';\r\n                    var replacement = '%s`'+(++uid)+'`s%';\r\n                    munged[uid] = string.replace(/^\\\\/,''); // strip the backslash now\r\n                    return replacement;\r\n                });\r\n            // need a loop here rather than .replace since we need to replace nested braces\r\n            var RE = full ? REfull : REbraces;\r\n            while(match = RE.exec(str)) {\r\n                replacement = '%b`'+(++uid)+'`b%';\r\n                munged[uid] = match[0];\r\n                str = str.replace(RE, replacement);\r\n            }\r\n            return str;\r\n        }\r\n\r\n        function restore(str) {\r\n            if(str === undefined) return str;\r\n            while(match = REmunged.exec(str)) {\r\n                str = str.replace(REmunged, munged[match[1]]);\r\n            }\r\n            return $.trim(str);\r\n        }\r\n\r\n        function processAtRule (rule, callback) {\r\n            var split = rule.split(/\\s+/); // split on whitespace\r\n            var type = split.shift(); // first word\r\n            if(type=='media') {\r\n                var css = restore(split.pop()).slice(1, -1); // last word is the rule; need to strip the outermost braces\r\n                if($.parsecss.mediumApplies(split.join(' '))) {\r\n                    $.parsecss(css, callback);\r\n                }\r\n            } else if (type=='import') {\r\n                var url = restore(split.shift());\r\n                if($.parsecss.mediumApplies(split.join(' '))) {\r\n                    url = url.replace(/^url\\(|\\)$/gi, '').replace(/^[\"']|[\"']$/g, ''); // remove the url('...') wrapper\r\n                    $.get(url, function(str) { $.parsecss(str, callback) });\r\n                }\r\n            }\r\n        }\r\n\r\n        // override show and hide. $.data(el, 'showDefault') is a function that is to be used for show if no arguments are passed in (if there are arguments, they override the stored function)\r\n        // Many of the effects call the native show/hide() with no arguments, resulting in an infinite loop.\r\n        var _show = {show: $.fn.show, hide: $.fn.hide}; // save the originals\r\n        $.each(['show', 'hide'], function() {\r\n            var which = this, show = _show[which], plugin = which+'Default';\r\n            $.fn[which] = function(){\r\n                if(arguments.length > 0) return show.apply(this, arguments);\r\n                return this.each(function() {\r\n                    var fn = $.data(this, plugin), $this = $(this);\r\n                    if(fn) {\r\n                        $.removeData(this, plugin); // prevent the infinite loop\r\n                        fn.call($this);\r\n                        $this.queue(function() { $this.data(plugin, fn).dequeue() }); // put the function back at the end of the animation\r\n                    } else {\r\n                        show.call($this);\r\n                    }\r\n                });\r\n            };\r\n            $.fn[plugin] = function() {\r\n                var args = $.makeArray(arguments), name = args[0];\r\n                if($.fn[name]) { // a plugin\r\n                    args.shift();\r\n                    var fn = $.fn[name];\r\n                } else if($.effects && $.effects[name]) { // a jQuery UI effect. They require an options object as the second argument\r\n                    if(typeof args[1] != 'object') args.splice(1, 0, {});\r\n                    fn = _show[which];\r\n                } else { // regular show/hide\r\n                    fn = _show[which];\r\n                }\r\n                return this.data(plugin, function() { fn.apply(this,args) });\r\n            };\r\n        });\r\n\r\n        // experimental: find unrecognized style attributes in elements by reloading the code as text\r\n        var RESGMLcomment = /<!--([^-]|-[^-])*-->/g; // as above, a simplification of real comments. Don't put -- in your HTML comments!\r\n        var REnotATag = /(>)[^<]*/g;\r\n        var REtag = /<(\\w+)([^>]*)>/g;\r\n\r\n        function styleAttributes(HTMLtext, callback) {\r\n            var ret = '', style, tags = {}; //  keep track of tags so we can identify elements unambiguously\r\n            HTMLtext = HTMLtext.replace(RESGMLcomment, '').replace(REnotATag, '$1');\r\n            munge(HTMLtext).replace(REtag, function(s, tag, attrs) {\r\n                tag = tag.toLowerCase();\r\n                if(tags[tag]) ++tags[tag]; else tags[tag] = 1;\r\n                if(style = /\\bstyle\\s*=\\s*(%s`\\d+`s%)/i.exec(attrs)) { // style attributes must be of the form style = \"a: bc\" ; they must be in quotes. After munging, they are marked with numbers. Grab that number\r\n                    var id = /\\bid\\s*=\\s*(\\S+)/i.exec(attrs); // find the id if there is one.\r\n                    if (id) id = '#'+restore(id[1]).replace(/^['\"]|['\"]$/g,''); else id = tag + ':eq(' + (tags[tag]-1) + ')';\r\n                    ret += [id, '{', restore(style[1]).replace(/^['\"]|['\"]$/g,''),'}'].join('');\r\n                }\r\n            });\r\n            $.parsecss(ret, callback);\r\n        }\r\n    })();\r\n\r\n\r\n    /*\r\n     * Lettering.JS 0.6.1\r\n     *\r\n     * Copyright 2010, Dave Rupert http://daverupert.com\r\n     * Released under the WTFPL license\r\n     * http://sam.zoy.org/wtfpl/\r\n     *\r\n     * Thanks to Paul Irish - http://paulirish.com - for the feedback.\r\n     *\r\n     * Date: Mon Sep 20 17:14:00 2010 -0600\r\n     */\r\n    (function() {\r\n        function injector(t, splitter, klass, after) {\r\n            var a = t.text().split(splitter), inject = '';\r\n            if (a.length) {\r\n                $(a).each(function(i, item) {\r\n                    inject += '<span class=\"'+klass+(i+1)+'\">'+item+'</span>'+after;\r\n                });\r\n                t.empty().append(inject);\r\n            }\r\n        }\r\n\r\n        var methods = {\r\n            init: function() {\r\n                return this.each(function() {\r\n                    injector($(this), '', 'char', '');\r\n                });\r\n            },\r\n\r\n            words: function() {\r\n                return this.each(function() {\r\n                    injector($(this), ' ', 'word', ' ');\r\n                });\r\n            },\r\n\r\n            lines: function() {\r\n                return this.each(function() {\r\n                    var r = \"eefec303079ad17405c889e092e105b0\";\r\n                    // Because it's hard to split a <br/> tag consistently across browsers,\r\n                    // (*ahem* IE *ahem*), we replaces all <br/> instances with an md5 hash\r\n                    // (of the word \"split\").  If you're trying to use this plugin on that\r\n                    // md5 hash string, it will fail because you're being ridiculous.\r\n                    injector($(this).children(\"br\").replaceWith(r).end(), r, 'line', '');\r\n                });\r\n            }\r\n        };\r\n\r\n        $.fn.lettering = function(method) {\r\n            // Method calling logic\r\n            if (method && methods[method]) {\r\n                return methods[method].apply(this, [].slice.call( arguments, 1 ));\r\n            } else if (method === 'letters' || !method) {\r\n                return methods.init.apply(this, [].slice.call( arguments, 0 )); // always pass an array\r\n            }\r\n            $.error('Method ' +  method + ' does not exist on jQuery.lettering');\r\n            return this;\r\n        };\r\n    })();\r\n\r\n\r\n    /*\r\n     *  Adapted from Font UnStack 0.1\r\n     *\r\n     *  Developed by Phil Oye\r\n     *  Copyright (c) 2009 Phil Oye, http://philoye.com/\r\n     *\r\n     *  Licensed under the MIT license:\r\n     *  http://www.opensource.org/licenses/mit-license.php\r\n     *\r\n     */\r\n    var unstack = (function() {\r\n        var fontunstack = {\r\n            init: function(elem){\r\n                var stack = $(elem).css('font-family').match(/[^'\",;\\s][^'\",;]*/g) || [];\r\n                return this.analyzeStack(stack, elem);\r\n            },\r\n\r\n            analyzeStack: function(stack, elems) {\r\n                var generics = [\"monospace\", \"sans-serif\", \"serif\", \"cursive\", \"fantasy\"];\r\n                var baseline = generics[0];\r\n                var num_fonts = stack.length;\r\n                var last_resort = stack[num_fonts - 1];\r\n\r\n                // If author hasn't included a generic (tsk, tsk), let's add one\r\n                if($.inArray(last_resort, generics)) {\r\n                    stack.push(baseline);\r\n                    num_fonts++;\r\n                }\r\n\r\n                // If the generic is the same as our baseline, let's use another.\r\n                if(last_resort == baseline) {\r\n                    baseline = generics[1];\r\n                };\r\n\r\n                // At this point we're sure there is a generic fallback font, so we'll only iterate though the non-generics.\r\n                for(var i=0; i < num_fonts - 1; i++) {\r\n                    font = stack[i];\r\n                    if(fontunstack.testFont(font, baseline)) {\r\n                        return font;\r\n                    }\r\n                }\r\n            },\r\n\r\n            testFont: function(requested_font, baseline_font) {\r\n                var span = $('<span id=\"font_tester\" style=\"font-family:' + baseline_font + '; font-size:144px;position:absolute;left:-10000px;top:-10000px;visibility:hidden;\">mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmml</span>');\r\n                $(\"body\").prepend(span);\r\n\r\n                var baseline_width = span.width();\r\n                span.css(\"font-family\", requested_font + \",\" + baseline_font );\r\n                var requested_width = span.width();\r\n                span.remove();\r\n\r\n                // If the dimensions change, the font is installed\r\n                return (requested_width != baseline_width);\r\n            }\r\n        };\r\n\r\n        return function(element) {\r\n            return fontunstack.init(element);\r\n        };\r\n    })();\r\n\r\n\r\n    /*\r\n     * Kerning.js\r\n     */\r\n    window.Kerning = new (function() {\r\n        /* Test for browsers & OSes. Ugly, but type rendering differs between\r\n         * browsers and operating systems. We need CSS flags to allow for that.\r\n         */\r\n        var self = this\r\n            , nav = navigator.platform\r\n            , browserPrefix = [\r\n            'webkitTransform' in document.documentElement.style && 'webkit'\r\n            , navigator.userAgent.indexOf(\"MSIE\") > -1 && 'ms'\r\n            , \"MozTransform\" in document.documentElement.style && 'moz'\r\n            , window.opera && 'o'\r\n        ].reduce(function(pv, cv) { return pv + (cv || ''); })\r\n            , osPrefix = [\r\n            nav.match(/Mac/) && 'mac'\r\n            , nav.match(/Win/) && 'win'\r\n            , nav.match(/Linux/) && 'linux'\r\n        ].reduce(function(pv, cv) { return pv + (cv || ''); });\r\n\r\n        var methods = {\r\n            // Match -[letter|word]-pairs(…) values\r\n            _pairs: function(type, elements, pairString) {\r\n                // checks for the existence of the letter pair property, i.e.: -letter-pairs(…)\r\n                var usingPairs = pairString.match(/^-(letter|word)-pairs\\(([\\s\\S]+)\\)$/i);\r\n                if(!usingPairs || usingPairs[1] !== type) return false;\r\n\r\n                var els = type === 'word'\r\n                        ? elements.children('span') // for -word-pairs\r\n                        : elements.find('span > span') // for -letter-pairs\r\n\r\n                    // we parse the string slightly differently if a transform is used\r\n                    , isTransform = pairString.match(/translate|rotate|skew|perspective/i)\r\n\r\n                    // matches and splits the pairing rules\r\n                    , pairs = $.trim(usingPairs[2].replace(/,\\s+?'/g, \",'\").replace(/:\\s+?(\\d)/g, ':$1')).split(isTransform ? '),' : ',')\r\n\r\n                    , pairInfo, pairKeys, pairDown\r\n                    , pairElements = [];\r\n                if(!pairs) return;\r\n\r\n                $.each(pairs, function(index, pair) {\r\n                    pairInfo = pair.split(':');\r\n                    // match the content inside the pair (stripping the leading and tailing quotes)\r\n                    // pairs may not be in quotes, or may have quotes inside quotes (i.e., 'a\"'), so we\r\n                    // prefer to do this with a regex.\r\n                    pairInfo[0] = pairInfo[0].replace(/^['\"](.+)['\"]$/g, '$1');\r\n\r\n                    if(type === 'word')\r\n                        pairKeys = pairInfo[0].split(' ');\r\n                    else\r\n                        pairKeys = pairInfo[0];\r\n\r\n                    pairDown = function(index) {\r\n                        var char1 = $(this).text().match(new RegExp(pairKeys[0])),\r\n                            nextWord, char2;\r\n                        if(pairKeys[1] !== ' ') {\r\n                            char2 = ($(this).next().html() || '').match(new RegExp(pairKeys[1]));\r\n                        } else {\r\n                            nextWord = type == 'word'\r\n                                ? $(this).next('[class^=\"word\"]')\r\n                                // if one of the pairKeys is just a space and we're doing letter pairs,\r\n                                // we, instead, need to check for the existence of the next word,\r\n                                // since spaces aren't wrapped\r\n                                : $(this).parent().next('[class^=\"word\"]');\r\n                            char2 = (!$(this).next().length && nextWord.length);\r\n                        }\r\n                        return char1 && char2;\r\n                    };\r\n\r\n                    pairElements.push([pairInfo[1], els.filter(pairDown)]);\r\n                });\r\n\r\n                return pairElements;\r\n            },\r\n\r\n            // Match -[letter|word]-repeats(…) values\r\n            _repeats: function(type, elements, repeatString) {\r\n                var usingRepeats = repeatString.match(/^-(letter|word)-repeats\\(([\\s\\S]+)\\)$/i);\r\n                if(!usingRepeats || usingRepeats[1] !== type) return false;\r\n\r\n                var els = type === 'word'\r\n                        ? elements.children('span')\r\n                        : elements.find('span > span'),\r\n                    isTransform = repeatString.match(/translate|rotate|skew|perspective/i),\r\n                    repeats = $.trim(usingRepeats[2].replace(/,\\s+?'/g, \",'\").replace(/:\\s+?(\\d)/g, ':$1')).split(isTransform ? '),' : ','),\r\n                    repeatInfo, repeatKeys, repeatDown,\r\n                    repeatElements = [];\r\n                if(!repeats) return;\r\n\r\n                $.each(repeats, function(index, repeat) {\r\n                    repeatInfo = repeat.split(':');\r\n                    if(isTransform && repeatInfo[1].substring(repeatInfo[1].length - 1) !== ')')\r\n                        repeatInfo[1] += ')';\r\n                    repeatElements.push([$.trim(repeatInfo[1]), els.filter(':nth-child(' + $.trim(repeatInfo[0]) + ')')]);\r\n                });\r\n\r\n                return repeatElements;\r\n            },\r\n\r\n            // Match [-[letter|word]-]if-font(…) values (-[letter|word]- is optional)\r\n            _conditional: function(type, elements, rule) {\r\n                var usingConditional = rule.match(/^(?:-(letter|word)-)?if-font\\(([\\s\\S]+)\\)$/i);\r\n                if(!usingConditional) return;\r\n\r\n                var els = type === 'all'\r\n                        ? elements\r\n                        : type === 'word'\r\n                        ? elements.children('span')\r\n                        : elements.find('span > span'),\r\n                    isTransform = rule.match(/translate|rotate|skew|perspective/i),\r\n                    fonts = usingConditional[2].replace(/\\n/g, '').match(/['\"][^'\"]+['\"]:\\s*.+?(\\)|(?=\\w),\\s['\"]|$)/g),\r\n                    fontInfo, fontElements = {}, elementSet = [];\r\n                if(!fonts) return;\r\n\r\n                elements.each(function(i, el) {\r\n                    var fontInUse = unstack(el).replace(/^['\"](.+)['\"]$/g, '$1');\r\n                    if(!fontElements[fontInUse])\r\n                        fontElements[fontInUse] = [el];\r\n                    else\r\n                        fontElements[fontInUse].push(el);\r\n                });\r\n\r\n                $.each(fonts, function(index, font) {\r\n                    fontInfo = font.match(/['\"]([^'\"]+)['\"]:\\s*(.+)$/);\r\n                    if(!fontInfo) return true;\r\n                    fontInfo = fontInfo.splice(1);\r\n                    if(fontInfo[0] in fontElements)\r\n                        elementSet.push([$.trim(fontInfo[1]), $(fontElements[fontInfo[0]])]);\r\n                });\r\n\r\n                return elementSet;\r\n            },\r\n\r\n            // Parse and apply a CSS property\r\n            _applyAttribute: function(type, elements, attribute, values) {\r\n                var conditional = methods._conditional(type, elements, values);\r\n                if(!conditional || !conditional.length)\r\n                    conditional = [[values, elements]];\r\n\r\n                $.each(conditional, function(a, ve) {\r\n                    var vals = ve[0], els = ve[1];\r\n                    var custom = methods._pairs(type, els, vals)\r\n                        || methods._repeats(type, els, vals);\r\n                    if(custom) {\r\n                        $.each(custom, function(index, valEl) {\r\n                            if(typeof attribute !== 'string') {\r\n                                var attrs = {};\r\n                                $.each(attribute, function(a, attr) { attrs[attr] = valEl[0]; });\r\n                                valEl[1].css(attrs);\r\n                            } else {\r\n                                valEl[1].css(attribute, valEl[0]);\r\n                            }\r\n                        });\r\n                    } else {\r\n                        var indexValues, keys, transformGroups;\r\n                        // check for transform groups, as we need to parse these slightly differently\r\n                        if(transformGroups = vals.match(/-transform-group\\(([\\s\\S]+?\\([^)]+\\))*?\\)/g)) {\r\n                            indexValues = $.map(transformGroups, function(val, i) {\r\n                                return val.replace(/-transform-group\\(([\\s\\S]+)\\)$/, '$1');\r\n                            });\r\n                        } else {\r\n                            indexValues = vals.replace(/[\\n\\s]+/g, ' ').split(' ');\r\n                        }\r\n\r\n                        els.each(function(i, el) {\r\n                            keys = type === 'all'\r\n                                ? $(el) // match the entire word (only used for certain use cases)\r\n                                : type === 'word'\r\n                                ? $(el).children('span')\r\n                                : $(el).find('span > span'); // letters are spans inside words\r\n                            $.each(indexValues, function(index, value) {\r\n                                if(typeof attribute !== 'string') {\r\n                                    var attrs = {};\r\n                                    $.each(attribute, function(a, attr) { attrs[attr] = value; });\r\n                                    keys.eq(index).css(attrs);\r\n                                } else {\r\n                                    keys.eq(index).css(attribute, value);\r\n                                }\r\n                            });\r\n                        });\r\n                    }\r\n                });\r\n            },\r\n\r\n            kern: function(type, elements, kerning) {\r\n                methods._applyAttribute(type, elements, 'margin-right', kerning);\r\n            },\r\n\r\n            size: function(type, elements, sizes) {\r\n                methods._applyAttribute(type, elements, 'font-size', sizes);\r\n            },\r\n\r\n            weight: function(type, elements, weights) {\r\n                methods._applyAttribute(type, elements, 'font-weight', weights);\r\n            },\r\n\r\n            color: function(type, elements, colors) {\r\n                methods._applyAttribute(type, elements, 'color', colors);\r\n            },\r\n\r\n            backgroundcolor: function(type, elements, colors) {\r\n                methods._applyAttribute(type, elements, 'background-color', colors);\r\n            },\r\n\r\n            transform: function(type, elements, transforms) {\r\n                var attributes = [\r\n                    '-webkit-transform'\r\n                    , '-moz-transform'\r\n                    , '-ms-transform'\r\n                    , '-o-transform'\r\n                    , 'transform'\r\n                ];\r\n                methods._applyAttribute(type, elements, attributes, transforms);\r\n            }\r\n        };\r\n\r\n        /**\r\n         * Scan the parsed CSS for properties we want, break them down and style them.\r\n         */\r\n        this._parse = function(css, ignoreParsed) {\r\n            if(!self._parsedCSS) self._parsedCSS = css; // cache the parsed CSS\r\n\r\n            for(var selector in css) {\r\n                for(var property in css[selector]) {\r\n                    var match,\r\n                        elements,\r\n                        value = css[selector][property];\r\n\r\n                    // Kerning.js prefixed selectors\r\n                    if(match = property.match(new RegExp('^(-' + browserPrefix + '|-' + osPrefix +')?-(letter|word)-(kern|transform|size|color|backgroundcolor|weight)', 'i'))) {\r\n                        var specificity = match[2].toLowerCase(),\r\n                            action = match[3].toLowerCase();\r\n\r\n                        elements = $(selector);\r\n                        if(ignoreParsed)\r\n                            elements = elements.not('.kerningjs');\r\n\r\n                        elements\r\n                            .not('.kerningjs')\r\n                            .addClass('kerningjs').css('visibility', 'inherit')\r\n                            .lettering('words').children('span').css('display', 'inline-block') // break down into words\r\n                            .lettering().children('span').css('display', 'inline-block'); // break down into letters\r\n\r\n                        if(methods[action])\r\n                            methods[action].call(this, specificity, elements, value);\r\n\r\n                        // existing selectors with Kerning.js-custom values\r\n                    } else if((match = property.match(/font-(size|weight)/i)) && value.match(/if-font/i)) {\r\n                        var action = match[1].toLowerCase();\r\n                        elements = $(selector);\r\n                        if(ignoreParsed)\r\n                            elements = elements.not('.kerningjs');\r\n\r\n                        elements\r\n                            .not('.kerningjs')\r\n                            .addClass('kerningjs').css('visibility', 'inherit');\r\n\r\n                        if(methods[action])\r\n                            methods[action].call(this, 'all', elements, value);\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n        /**\r\n         * Automatically re-run the script when a DOM node is inserted. This *could potentially*\r\n         * hurt the performance of your page, so I strongly recommend benchmarking what affect\r\n         * this will have on your site.\r\n         */\r\n        this.live = function() {\r\n            // Technically, this event is \"depricated,\" but there isn't exactly a whole\r\n            // boatload of alternatives. Or any alternatives. At all. Not one.\r\n            $(document).bind('DOMNodeInserted', function(evt) {\r\n                if(evt.target) self.refresh(true);\r\n            });\r\n        };\r\n\r\n        /**\r\n         * Re-runs the parser to apply styles; to only apply to new elements, set newElementsOnly to true.\r\n         */\r\n        this.refresh = function(newElementsOnly) {\r\n            if(self._parsedCSS)\r\n                self._parse(self._parsedCSS, newElementsOnly);\r\n        };\r\n\r\n        // Run the parser on DOM load\r\n        $(function() {\r\n            $(document).parsecss(self._parse, true);\r\n        });\r\n    })();\r\n})(jQuery);"]}